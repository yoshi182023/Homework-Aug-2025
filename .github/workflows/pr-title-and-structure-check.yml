name: PR Title & Folder Structure Check

on:
  pull_request_target:
    types: [opened, edited, synchronize, ready_for_review]

permissions:
  pull-requests: write
  contents: read

jobs:
  lint:
    if: ${{ !github.event.pull_request.draft }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const title = pr.title ?? "";
            const repo = context.repo;
            const headSha = pr.head.sha;

            // æ ‡é¢˜è§„åˆ™ï¼šHW{0..20} - {Name}ï¼ˆå¤§å°å†™ä¸æ•æ„Ÿï¼‰
            const titleRe = /^HW(0|[1-9]|1[0-9]|20)\s*-\s*\S.*$/i;

            // å›ºå®šé”šç‚¹ï¼Œé¿å…åˆ·å±
            const marker = '<!-- pr-hw-structure-lint -->';

            async function upsertComment(lines) {
              const body = [marker, ...lines].join('\n');
              const { data: comments } = await github.rest.issues.listComments({
                owner: repo.owner, repo: repo.repo, issue_number: pr.number, per_page: 100,
              });
              const existing = comments.find(c => c.body?.includes(marker));
              if (existing) {
                await github.rest.issues.updateComment({
                  owner: repo.owner, repo: repo.repo, comment_id: existing.id, body,
                });
              } else {
                await github.rest.issues.createComment({
                  owner: repo.owner, repo: repo.repo, issue_number: pr.number, body,
                });
              }
            }

            async function cleanupComment() {
              const { data: comments } = await github.rest.issues.listComments({
                owner: repo.owner, repo: repo.repo, issue_number: pr.number, per_page: 100,
              });
              const existing = comments.find(c => c.body?.includes(marker));
              if (existing) {
                await github.rest.issues.deleteComment({
                  owner: repo.owner, repo: repo.repo, comment_id: existing.id,
                });
              }
            }

            // âœ… æ”¹æˆæ™®é€š asyncï¼Œé¿å… IIFE å¼•èµ·çš„æ‹¬å·/ç¼©è¿›é—®é¢˜
            async function fail(lines) {
              await upsertComment(lines);
              core.setFailed('PR title/folder structure check failed');
            }

            // --- 1) æ ‡é¢˜æ ¡éªŒ ---
            if (!titleRe.test(title)) {
              await fail([
                `### ğŸš« PR æ ‡é¢˜æ ¼å¼é”™è¯¯`,
                ``,
                `ä½ çš„æ ‡é¢˜ï¼š\`${title}\``,
                ``,
                `**è¦æ±‚æ ¼å¼**ï¼š\`HW{#} - {Name}\`ï¼ˆå¤§å°å†™ä¸æ•æ„Ÿï¼‰`,
                `- \`#\` å¿…é¡»æ˜¯ **0..20** çš„æ•´æ•°`,
                `- ä¸­é—´è¦æœ‰è¿å­—ç¬¦ \`-\`ï¼ˆå¯ä»¥æœ‰ç©ºæ ¼ï¼‰`,
                `- {Name} è‡³å°‘è¦æœ‰ä¸€ä¸ªéç©ºç™½å­—ç¬¦`,
                ``,
                `**æ­£ç¡®ç¤ºä¾‹**ï¼š`,
                `- \`HW0 - Vincent\``,
                `- \`HW3 - Zoey\``,
                `- \`HW20 - Performance tuning\``,
                ``,
                `**ä¸åˆæ ¼ç¤ºä¾‹**ï¼š`,
                `- \`hw3\` ï¼ˆç¼ºå°‘è¿å­—ç¬¦å’Œåå­—ï¼‰`,
                `- \`HW21 - test\` ï¼ˆæ•°å­—è¶…å‡ºèŒƒå›´ï¼‰`,
                `- \`HW3- \` ï¼ˆç¼ºå°‘åå­—éƒ¨åˆ†ï¼‰`,
              ]);
              return;
            }

            const num = Number(title.match(/HW(0|[1-9]|1[0-9]|20)/i)[1]);

            // --- 2) è¯»å– PR æ–‡ä»¶åˆ—è¡¨ ---
            const files = [];
            for (let page = 1; ; page++) {
              const { data } = await github.rest.pulls.listFiles({
                owner: repo.owner, repo: repo.repo, pull_number: pr.number, per_page: 100, page,
              });
              files.push(...data);
              if (data.length < 100) break;
            }

            if (files.length === 0) {
              await fail([
                `### ğŸš« æ²¡æœ‰æ£€æµ‹åˆ°ä»»ä½•æ–‡ä»¶æ”¹åŠ¨`,
                ``,
                `è¯·ç¡®ä¿æäº¤äº†ä½äº \`HW${num}/{NAME_FOLDER}/\` ä¸‹çš„ä½œä¸šæ–‡ä»¶ï¼Œå¹¶ä¸”åŒ…å« \`note.md\`ã€‚`,
              ]);
              return;
            }

            // åªå…³æ³¨éåˆ é™¤æ”¹åŠ¨ï¼ˆå¦‚éœ€é˜»å¡åˆ é™¤ï¼ŒæŠŠ 'removed' ä¹ŸåŠ å…¥ï¼‰
            const activeFiles = files.filter(f => ['added','modified','renamed','copied','changed'].includes(f.status));

            const pathStartRe = new RegExp(`^HW${num}/([^/]+)/`); // æ•è· NAME_FOLDER
            const folders = new Set();
            let offending = null;
            let wrongHwExample = null;

            for (const f of activeFiles) {
              const p = f.filename;

              // a) ä¸èƒ½å‡ºç°åœ¨å…¶ä»– HW ç›®å½•
              const otherHwMatch = p.match(/^HW(\d+)\//i);
              if (otherHwMatch && Number(otherHwMatch[1]) !== num) {
                wrongHwExample = p;
                break;
              }

              // b) å¿…é¡»åœ¨ HW{num}/{NAME_FOLDER}/ ä¹‹ä¸‹
              if (!p.startsWith(`HW${num}/`)) {
                offending = p; break;
              }
              const m = p.match(pathStartRe);
              if (!m) { offending = p; break; }
              folders.add(m[1]);
            }

            if (wrongHwExample) {
              await fail([
                `### ğŸš« ä½œä¸šå·ä¸ä¸€è‡´`,
                ``,
                `æ ‡é¢˜ä¸­çš„ä½œä¸šå·ï¼š\`HW${num}\``,
                `ä½†æ£€æµ‹åˆ°å…¶ä»–ç›®å½•ï¼š\`${wrongHwExample}\``,
                ``,
                `**è¦æ±‚ï¼š** æœ¬æ¬¡ PR çš„æ”¹åŠ¨åªèƒ½å‡ºç°åœ¨ \`HW${num}/{NAME_FOLDER}/\` ä¸‹ã€‚`,
                `âœ… ç¤ºä¾‹ï¼š\`HW${num}/Vincent/note.md\``,
              ]);
              return;
            }

            if (offending) {
              await fail([
                `### ğŸš« å˜æ›´è·¯å¾„ä¸ç¬¦åˆè§„èŒƒ`,
                ``,
                `æ–‡ä»¶ï¼š\`${offending}\``,
                ``,
                `**è¦æ±‚ï¼š** æ‰€æœ‰æ”¹åŠ¨æ–‡ä»¶å¿…é¡»æ”¾åœ¨ \`HW${num}/{NAME_FOLDER}/\` ç›®å½•ä¸‹ã€‚`,
                `âœ… æ­£ç¡®ç¤ºä¾‹ï¼š\`HW${num}/Vincent/note.md\`ã€\`HW${num}/Vincent/å½•éŸ³.mp4\``,
                `âŒ é”™è¯¯ç¤ºä¾‹ï¼š\`HW${num}/note.md\`ã€\`HW${num}/question.js\``,
              ]);
              return;
            }

            if (folders.size !== 1) {
              await fail([
                `### ğŸš« æ£€æµ‹åˆ°å¤šä¸ª {NAME_FOLDER}`,
                ``,
                `å½“å‰æ£€æµ‹åˆ°ï¼š\`${[...folders].join('`, `')}\``,
                ``,
                `**è¦æ±‚ï¼š** æ¯ä¸ª PR åªèƒ½æäº¤ä¸€ä¸ªä½œä¸šæ–‡ä»¶å¤¹ã€‚`,
              ]);
              return;
            }

            const folder = [...folders][0];

            // --- 3) å¿…é¡»å­˜åœ¨ note.mdï¼ˆæ£€æŸ¥ PR head æäº¤çš„æ–‡ä»¶æ ‘ï¼‰ ---
            try {
              await github.rest.repos.getContent({
                owner: repo.owner,
                repo: repo.repo,
                path: `HW${num}/${folder}/note.md`,
                ref: headSha,
              });
            } catch (err) {
              await fail([
                `### ğŸš« ç¼ºå°‘å¿…éœ€æ–‡ä»¶ note.md`,
                ``,
                `æœªæ£€æµ‹åˆ°ï¼š\`HW${num}/${f
