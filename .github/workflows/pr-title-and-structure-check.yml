name: PR Title & Folder Structure Check

on:
  pull_request_target:
    types: [opened, edited, synchronize, ready_for_review]

permissions:
  pull-requests: write
  contents: read

jobs:
  lint:
    if: ${{ !github.event.pull_request.draft }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const title = pr.title ?? "";
            const repo = context.repo;
            const headSha = pr.head.sha;

            const titleRe = /^HW(0|[1-9]|1[0-9]|20)\s*-\s*\S.*$/i;
            const marker = '<!-- pr-hw-structure-lint -->';

            async function upsertComment(lines) {
              const body = [marker, ...lines].join('\n');
              const { data: comments } = await github.rest.issues.listComments({
                owner: repo.owner, repo: repo.repo, issue_number: pr.number, per_page: 100,
              });
              const existing = comments.find(c => c.body?.includes(marker));
              if (existing) {
                await github.rest.issues.updateComment({
                  owner: repo.owner, repo: repo.repo, comment_id: existing.id, body,
                });
              } else {
                await github.rest.issues.createComment({
                  owner: repo.owner, repo: repo.repo, issue_number: pr.number, body,
                });
              }
            }

            async function cleanupComment() {
              const { data: comments } = await github.rest.issues.listComments({
                owner: repo.owner, repo: repo.repo, issue_number: pr.number, per_page: 100,
              });
              const existing = comments.find(c => c.body?.includes(marker));
              if (existing) {
                await github.rest.issues.deleteComment({
                  owner: repo.owner, repo: repo.repo,
                  comment_id: existing.id,
                });
              }
            }

            function fail(lines) {
              return (async () => {
                await upsertComment(lines);
                core.setFailed('PR title/folder structure check failed');
              })();
            }

            // --- æ ‡é¢˜æ ¡éªŒ ---
            if (!titleRe.test(title)) {
              await fail([
                `### ğŸš« PR æ ‡é¢˜æ ¼å¼é”™è¯¯`,
                ``,
                `ä½ çš„æ ‡é¢˜ï¼š\`${title}\``,
                ``,
                `**è¦æ±‚æ ¼å¼**ï¼š\`HW{#} - {Name}\`ï¼ˆå¤§å°å†™ä¸æ•æ„Ÿï¼‰`,
                `- \`#\` å¿…é¡»æ˜¯ **0..20** çš„æ•´æ•°`,
                `- ä¸­é—´è¦æœ‰è¿å­—ç¬¦ \`-\`ï¼ˆå¯ä»¥æœ‰ç©ºæ ¼ï¼‰`,
                `- {Name} è‡³å°‘è¦æœ‰ä¸€ä¸ªéç©ºç™½å­—ç¬¦`,
                ``,
                `**æ­£ç¡®ç¤ºä¾‹**ï¼š`,
                `- \`HW0 - Bean\``,
                `- \`HW3 - Zoey\``,
                `- \`HW20 - Performance tuning\``,
                ``,
                `âŒ ä¸åˆæ ¼ç¤ºä¾‹ï¼š`,
                `- \`hw3\` ï¼ˆç¼ºå°‘è¿å­—ç¬¦å’Œåå­—ï¼‰`,
                `- \`HW21 - test\` ï¼ˆæ•°å­—è¶…å‡ºèŒƒå›´ï¼‰`,
                `- \`HW3- \` ï¼ˆç¼ºå°‘åå­—éƒ¨åˆ†ï¼‰`,
              ]);
              return;
            }

            const num = Number(title.match(/HW(0|[1-9]|1[0-9]|20)/i)[1]);

            // --- è¯»å–æ–‡ä»¶åˆ—è¡¨ ---
            const files = [];
            for (let page = 1; ; page++) {
              const { data } = await github.rest.pulls.listFiles({
                owner: repo.owner, repo: repo.repo, pull_number: pr.number, per_page: 100, page,
              });
              files.push(...data);
              if (data.length < 100) break;
            }
            if (files.length === 0) {
              await fail([
                `### ğŸš« æ²¡æœ‰æ£€æµ‹åˆ°ä»»ä½•æ–‡ä»¶æ”¹åŠ¨`,
                ``,
                `è¯·ç¡®ä¿æäº¤äº†ä½äº \`HW${num}/{NAME_FOLDER}/\` ä¸‹çš„ä½œä¸šæ–‡ä»¶ï¼Œå¹¶ä¸”åŒ…å« \`note.md\`ã€‚`
              ]);
              return;
            }

            const activeFiles = files.filter(f => ['added','modified','renamed','copied','changed'].includes(f.status));
            const pathStartRe = new RegExp(`^HW${num}/([^/]+)/`);
            const folders = new Set();
            let mismatchExample = null;

            for (const f of activeFiles) {
              const p = f.filename;
              if (!p.startsWith(`HW${num}/`)) {
                mismatchExample = p;
                break;
              }
              const m = p.match(pathStartRe);
              if (!m) {
                mismatchExample = p;
                break;
              }
              folders.add(m[1]);
            }

            if (mismatchExample) {
              await fail([
                `### ğŸš« ä½œä¸šå·
