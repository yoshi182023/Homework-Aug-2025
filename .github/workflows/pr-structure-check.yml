name: PR Structure Check
on:
  pull_request:
    types: [opened, edited, synchronize, ready_for_review]

permissions:
  pull-requests: write
  contents: read

jobs:
  structure:
    name: PR Structure Check
    if: ${{ !github.event.pull_request.draft }}
    runs-on: ubuntu-latest
    steps:
      - name: Check PR structure and note.md
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request || {};
            const repo = context.repo;
            const title = pr.title || "";
            const headSha = pr.head && pr.head.sha ? pr.head.sha : "";
            const MARK = "<!-- pr-structure-lint -->";

            async function upsert(lines){
              const body = [MARK].concat(lines).join("\n");
              const resp = await github.rest.issues.listComments({ owner: repo.owner, repo: repo.repo, issue_number: pr.number, per_page: 100 });
              const ex = (resp.data || []).find(c => c.body && c.body.indexOf(MARK) !== -1);
              if (ex) { await github.rest.issues.updateComment({ owner: repo.owner, repo: repo.repo, comment_id: ex.id, body }); }
              else   { await github.rest.issues.createComment({ owner: repo.owner, repo: repo.repo, issue_number: pr.number, body }); }
            }
            async function cleanup(){
              const resp = await github.rest.issues.listComments({ owner: repo.owner, repo: repo.repo, issue_number: pr.number, per_page: 100 });
              const ex = (resp.data || []).find(c => c.body && c.body.indexOf(MARK) !== -1);
              if (ex) { await github.rest.issues.deleteComment({ owner: repo.owner, repo: repo.repo, comment_id: ex.id }); }
            }
            async function safeUpsert(lines){ try{ await upsert(lines); }catch(e){ core.warning("Cannot comment: " + (e.message||e)); } }
            async function safeCleanup(){ try{ await cleanup(); }catch(e){} }
            async function fail(lines){ await safeUpsert(lines); core.setFailed("PR structure invalid"); }

            // ä»æ ‡é¢˜è§£ææ•´æ•°ä½œä¸šå·ï¼ˆ0 æˆ–æ­£æ•´æ•°ï¼Œé»˜è®¤ä¸å…è®¸å‰å¯¼ 0ï¼‰
            const m = title.match(/HW(0|[1-9]\d*)/i);
            if (!m) {
              await fail([
                "### ğŸš« æ— æ³•è§£æä½œä¸šå·",
                "",
                "å½“å‰æ ‡é¢˜ï¼š`" + title + "`",
                "è¯·å…ˆæŠŠæ ‡é¢˜æ”¹æˆ `HW{æ•´æ•°} - {Name}`ï¼ˆå¦‚ `HW0 - Bean`, `HW42 - Zoey`ï¼‰ã€‚"
              ]);
              return;
            }
            const num = Number(m[1]);

            // æ‹‰å– PR æ–‡ä»¶åˆ—è¡¨
            const files = [];
            let page = 1;
            while (true) {
              const resp = await github.rest.pulls.listFiles({ owner: repo.owner, repo: repo.repo, pull_number: pr.number, per_page: 100, page });
              const data = resp.data || [];
              for (const it of data) files.push(it);
              if (data.length < 100) break;
              page += 1;
            }
            if (files.length === 0) {
              await fail([
                "### ğŸš« æœªæ£€æµ‹åˆ°ä»»ä½•æ–‡ä»¶æ”¹åŠ¨",
                "",
                "è¯·åœ¨ `HW" + num + "/{NAME_FOLDER}/` ä¸‹æäº¤ä½œä¸šæ–‡ä»¶ï¼Œå¹¶åŒ…å« `note.md`ã€‚"
              ]);
              return;
            }

            // ä»…æ£€æŸ¥éåˆ é™¤æ”¹åŠ¨
            const active = files.filter(f => ["added","modified","renamed","copied","changed"].indexOf(f.status||"") !== -1);

            const wrongHwFiles = [];         // ä½äºå…¶ä»– HW å·ç›®å½•
            const outsideHwFiles = [];       // ä¸åœ¨ HW{num}/ å‰ç¼€ä¸‹
            const noNameFolderFiles = [];    // åœ¨ HW{num}/ ä¸‹ï¼Œä½†æ²¡æœ‰ {NAME_FOLDER}/ è¿™ä¸€çº§ï¼Œå¦‚ HW{num}/note.md
            const folders = new Set();       // ç»Ÿè®¡å‡ºç°è¿‡çš„ {NAME_FOLDER}
            const pathStartRe = new RegExp("^HW" + num + "/([^/]+)/");

            for (const f of active) {
              const p = f.filename || "";

              const oh = p.match(/^HW(\d+)\//i);
              if (oh && Number(oh[1]) !== num) { wrongHwFiles.push(p); continue; }

              if (p.indexOf("HW" + num + "/") !== 0) { outsideHwFiles.push(p); continue; }

              const mm = p.match(pathStartRe);
              if (!mm) { noNameFolderFiles.push(p); continue; }

              folders.add(mm[1]);
            }

            // å¦‚æœæœ‰ä»»æ„ä¸€ç±»è¿è§„ï¼Œåˆ—å‡ºâ€œå…¨éƒ¨è¿è§„æ–‡ä»¶â€
            if (wrongHwFiles.length || outsideHwFiles.length || noNameFolderFiles.length) {
              const lines = [];
              lines.push("### ğŸš« å˜æ›´è·¯å¾„ä¸ç¬¦åˆè§„èŒƒ");
              lines.push("");
              lines.push("æ ‡é¢˜ä¸­çš„ä½œä¸šå·ï¼š`HW" + num + "`");
              lines.push("");

              if (wrongHwFiles.length) {
                lines.push("**å‡ºç°åœ¨å…¶ä»–ä½œä¸šç›®å½•ï¼ˆåº”ä¸º `HW" + num + "/...`ï¼‰ï¼š" + " å…± " + wrongHwFiles.length + " ä¸ª**");
                for (const p of wrongHwFiles) lines.push("- `" + p + "`");
                lines.push("");
              }
              if (outsideHwFiles.length) {
                lines.push("**ä¸åœ¨ `HW" + num + "/` å‰ç¼€ä¸‹ï¼š" + " å…± " + outsideHwFiles.length + " ä¸ª**");
                for (const p of outsideHwFiles) lines.push("- `" + p + "`");
                lines.push("");
              }
              if (noNameFolderFiles.length) {
                lines.push("**ç¼ºå°‘ `{NAME_FOLDER}` è¿™ä¸€çº§ï¼ˆå½¢å¦‚ `HW" + num + "/note.md`ï¼‰ï¼šå…± " + noNameFolderFiles.length + " ä¸ª**");
                for (const p of noNameFolderFiles) lines.push("- `" + p + "`");
                lines.push("");
              }

              lines.push("**è¦æ±‚ï¼š** æ‰€æœ‰æ”¹åŠ¨æ–‡ä»¶å¿…é¡»ä½äº `HW" + num + "/{NAME_FOLDER}/**`ã€‚");
              lines.push("âœ… ç¤ºä¾‹ï¼š`HW" + num + "/Bean/note.md`ã€`HW" + num + "/Bean/å½•éŸ³.mp4`");
              lines.push("âŒ ç¤ºä¾‹ï¼š`HW" + num + "/note.md`ã€`HW" + num + "/question.js`ã€`HW" + (num+1) + "/...`");
              await fail(lines);
              return;
            }

            // åˆ°è¿™é‡Œè¯´æ˜æ‰€æœ‰æ–‡ä»¶éƒ½åœ¨ HW{num}/{NAME_FOLDER}/** ä¸‹
            if (folders.size !== 1) {
              const lines = [];
              lines.push("### ğŸš« æ£€æµ‹åˆ°å¤šä¸ª {NAME_FOLDER}");
              lines.push("");
              lines.push("æœ¬æ¬¡ PR åªèƒ½æœ‰ä¸€ä¸ªä½œä¸šæ–‡ä»¶å¤¹ï¼Œå½“å‰æ£€æµ‹åˆ°ï¼š" + "`" + Array.from(folders).join("`, `") + "`");
              lines.push("");
              lines.push("**è¦æ±‚ï¼š** æ‰€æœ‰æ”¹åŠ¨åº”ä½äº `HW" + num + "/{å”¯ä¸€çš„NAME_FOLDER}/` ä¸‹ã€‚");
              await fail(lines);
              return;
            }

            const folder = Array.from(folders)[0];

            // å¿…é¡»å­˜åœ¨ note.mdï¼ˆæŒ‰ PR head æäº¤æ£€æŸ¥ï¼‰
            try {
              await github.rest.repos.getContent({
                owner: repo.owner, repo: repo.repo,
                path: "HW" + num + "/" + folder + "/note.md",
                ref: headSha
              });
            } catch (e) {
              await fail([
                "### ğŸš« ç¼ºå°‘å¿…éœ€æ–‡ä»¶ note.md",
                "",
                "æœªæ£€æµ‹åˆ°ï¼š`HW" + num + "/" + folder + "/note.md`ï¼ˆæŒ‰å½“å‰ PR å¤´éƒ¨æäº¤ï¼‰",
                "",
                "**è¦æ±‚ï¼š** åœ¨ä½ çš„ä½œä¸šæ–‡ä»¶å¤¹ä¸­æ·»åŠ  `note.md`ï¼ˆåŒºåˆ†å¤§å°å†™ï¼‰ã€‚"
              ]);
              return;
            }

            await safeCleanup();
            core.info("âœ… Structure OK: HW" + num + "/" + folder);
